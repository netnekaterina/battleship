
# Математическая модель алгоритма для "Морского боя с минами"

## 1. Формализация задачи
Игровое поле — это матрица размера $N \times N$, где для каждой клетки $(i, j)$ определены следующие состояния:

- $S_{ij} \in \{0,1\}$ — наличие корабля (1 — есть, 0 — нет)
- $M_{ij} \in \{0,1\}$ — наличие мины
- $R_{ij} \in \{0,1\}$ — проверена ли клетка

## 2. Вероятностные распределения
Для каждой клетки рассчитываются две вероятности:

- $P^s_{ij}$ — вероятность наличия корабля
- $P^m_{ij}$ — вероятность наличия мины

Начальные значения:

- $P^s_{ij} = \frac{\text{число палуб}}{N^2}$
- $P^m_{ij} = \frac{\text{число мин}}{N^2}$

## 3. Функция полезности выстрела
Алгоритм оценивает "выгодность" выстрела по формуле:

$$U(i,j) = P^s_{ij} - \lambda \cdot P^m_{ij}$$

где $\lambda$ — коэффициент риска. Он рассчитывается как:

$$\lambda = \lambda_{max} \cdot \left(1 - \frac{L}{L_{max}}\right)$$

где $L$ — текущее количество жизней, $L_{max}$ — максимальное.

## 4. Обновление вероятностей после выстрела
- Попадание в корабль: $P^s_{ij} = 1$, у соседей снижается, активируется режим добивания (DFS).
- Попадание в мину: $P^m_{ij} = 1$, $L = L - 1$, вероятности мин для соседей увеличиваются.
- Промах: $P^s_{ij} = 0$, $P^m_{ij} = 0$

## 5. Алгоритмические компоненты
- **Жадный выбор**: выбор клетки с максимальной полезностью $U(i,j)$.
- **DFS-добивание**: исследование направлений при попадании в корабль.
- **Backtracking**: откат к безопасной стратегии при потере жизни.

## 6. Оптимизационные параметры
- Размер поля $N$
- Радиус опасности мин (по желанию)
- Форма зависимости $\lambda$ от жизней
- Порог переключения стратегий

## 7. Валидация
Оценка точности и эффективности алгоритма проводится на серии симуляций и сравнении с базовыми стратегиями: случайной, классической жадной и т.д.

## 8. Отличия от классического Battleship
- Мины: отдельный слой вероятностей
- Ограниченные жизни
- Адаптивность алгоритма через динамическое $\lambda$

---

## 9. Стратегия правильной стрельбы по квадратам (поиск максимального корабля)
### Идея:
На первом этапе алгоритм не стреляет "вслепую", а делит поле на квадраты размером $n \times n$, где $n$ — длина самого большого оставшегося корабля. В каждом квадрате выбирается специальный шаблон выстрелов, чтобы гарантировать: ни один корабль длиной $n$ не сможет полностью поместиться в непоражённые клетки этого квадрата.

### Шаги алгоритма:
Определить максимальную длину оставшегося корабля $n$.
Разбить поле на квадраты $n \times n$ (например, для классики $n=4$ — квадраты $4 \times 4$).
В каждом квадрате прострелить клетки по одному из специальных шаблонов (см. рисунки ниже), чтобы исключить возможность размещения корабля длиной $n$.
После уничтожения всех кораблей длиной $n$ перейти к следующему по длине ($n-1$) и повторить процедуру (например, делить на $3 \times 3$ и искать трёхпалубники).
Пример для $n=4$ (четырёхпалубник):
Поле $10 \times 10$ делится на 4 полных квадрата $4 \times 4$ и остатки.
В каждом квадрате выбирается один из 7 уникальных шаблонов выстрелов (см. рисунки ниже).
После прострела по этим шаблонам четырёхпалубник не сможет уместиться ни в одном квадрате без попадания.
Преимущества метода
Минимизация количества выстрелов для обнаружения самых длинных кораблей.
Системный подход: поле простреливается по шаблонам, а не случайно.
Гибкость: после уничтожения всех кораблей максимальной длины, стратегия автоматически адаптируется к поиску меньших кораблей.
Иллюстрации
На рисунках ниже показано деление поля на квадраты и примеры шаблонов выстрелов для $4 \times 4$ и $3 \times 3$:
<p align="center">
<img src="пример_деления_на_квадраты.png" width="300"/>
<img src="шаблоны_выстрелов_4x4.png" width="300"/>
<img src="прострел_всего_поля.png" width="300"/>
<img src="шаблоны_выстрелов_3x3.png" width="300"/>
</p>
P.S.
Реализация этого алгоритма позволяет существенно повысить эффективность поиска кораблей и минимизировать количество промахов на начальном этапе игры.